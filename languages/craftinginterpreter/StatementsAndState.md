# 语句和状态

> 我的心一生都在追随一个我难以言状的东西
> 
>                         -------André Breton, *Mad Love*

目前的解释器不太能运行真正的语言而更像是在计算器上打按钮。“编程”对我来说意味着从小的片段逐步构建一个系统。我们尚不能那么做因为我们还没法把名字绑定到每个数据或函数。完成这部分才能组成软件。

为了支持绑定，我们的解释器需要内部状态。当你在程序开始定义一个变量然后使用它的时候，解释器在这期间得保存变量的值。所以在本章，我们将给我们的解释器装一个大脑，不仅能运行，而且能记忆。

状态和语句携手并进，根据定义，语句不计算一个值，它们需要做一些更有用的被称为副作用的事。那意味着产生用户可见的输出或是修改了解释器的一些状态且日后可以被侦测到。后者使定义变量或命名的实体很合适。

在这章，我们实现上述所说的。我们定义能产出的语句(print)和状态(var)。我们添加表达式访问和变量赋值。最后我们加上块和本地范围。这对于一章来说很多，但是我们这次要一餐吃完。

## 语句

我们开始用语句扩展Lox的语法。它们和表达式没什么不同。我们从这两个简单的种类入手：

1. 一个**表达式语句**让你把表达式放在一个期望是语句的地方。用它们来评估表达式是否有副作用。你可能没注意，但是你在c语言、java和其他语言中到处都用到。每次你看到函数或是方法被调用并跟着一个 “；” ，你就看到了一个表达式语句。

2. 一个**输出语句**运行表达式并展示结果给用户。我承认直接把输出作为关键字而不是库函数有些许怪异。这么做是为了迁就我们每章都要构建一部分并且能运行的条件。如果实现为库函数，我们得等到构建好所有基础设施才能看到一些效果。

新的语法意味着新的语法规则。在本章，我们最终会获得解析整个Lox脚本的能力。由于Lox是一个命令式的、动态类型的语言，所以“高层的”脚本仅仅是一些语句。以下是新的规则：

```c
program        → statement* EOF ;

statement      → exprStmt
               | printStmt ;

exprStmt       → expression ";" ;
printStmt      → "print" expression ";" ;
```

第一个规则的`program`是这个语法的开始，代表着一个完整的Lox脚本或交互执行的实体。一个程序是以“`end of file`”token结尾的一系列语句。这一强制的token确保词法分析器解析了整个输入而没有默默的忽视了一些tokens

现在，`statement`只有如上描述的两种情况，我们将在本章和下一章填入更多。下一步是把这些语法变成一些可以寻出在记忆中的东西------语法树

## 语句语法树

语法中没有地方允许表达式和语句。运算符，例如`+`总是表达式，从不是语句。`while`循环的身体总是语句。

由于这两个语法是不相关的，我们不用一个基础的类使所有类都继承它。


